#!/usr/bin/env nu
use std log

# ----------------------------------------
# System check: Ensure running on macOS
# ----------------------------------------
def assert-macos [] {
    let sys = (sys host | get name)
    if $sys != "macos" and $sys != "Darwin" {
      error make {
        msg: $"This command only works on macOS. Detected: ($sys)",
      }
    }
}

assert-macos

## utils

# Helper: run or preview an AppleScript cmd
def run-applescript [
  cmd: string,
  debug: bool,
  dry_run: bool,
] {
  if $dry_run {
    log info $"[dry-run] Would execute AppleScript : ($cmd)"
    return $"osascript -e '($cmd)'"
  }
  if $debug {
    log info $"Executing AppleScript: ($cmd)"
  }
  try {
    osascript -e $cmd | str trim
  } catch {
    let err = (error-message)
    log error $"AppleScript failed: ($err)"
    error make {
      msg: $"Failed to run: osascript -e '($cmd)'"
    }
  }
}

# shutdown macos
def "main shutdown" [
  --force(-f), # Force shutdown
  --debug(-d), # show log
  --dry-run, # Do not execute; show what would run
]: nothing -> string {
  let cmd = if $force {
    'tell app "System Events" to shut down'
  } else {
    'tell app "loginwindow" to «event aevtrsdn»'
  }
  run-applescript $cmd $debug $dry_run
}

# reboot macos
def "main reboot" [
  --force(-f), # Force reboot
  --debug(-d), # show log
  --dry-run, # Do not execute; show what would run
]: nothing -> string {
  let cmd = if $force {
    'tell app "System Events" to restart'
  } else {
    'tell app "loginwindow" to «event aevtrrst»'
  }
  run-applescript $cmd $debug $dry_run
}

# Trash some command

# check privilege
def check-transh-privilege [] {
  try {
    ls ($env.HOME | path join ".Trash")
    return true
  } catch {
    log debug "This reuires Terminal 'Full Disk Access' permission to work properly."
    return false
  }
}

def trash-clean [
  debug: bool, # show log
  dry_run: bool, # Do not execute; show what would run
] {
  let cmd = 'tell application "Finder" to empty the trash'
  run-applescript  $cmd  $debug $dry_run
}

def trash-status [] {
  let trash_home = $env.Home | path join ".Trash"
  let trash_size = du $trash_home | get physical | first
  let trash_files = (glob -D $"($trash_home)/**" | length) - 1
  print $"Size: ($trash_size)"
  print $"Number of files: ($trash_files)"
}

# trash command
def "main trash" [
  --status(-s), # show the status of the trash
  --clean(-c), # Clean the trash
  --debug(-d), # show log
  --dry-run # Do not execute; show what would run
] {
  if (check-transh-privilege) {
    if $status {
      trash-status
      return
    }
    if $clean {
      trash-clean $debug $dry_run
      return
    }
    help main
  } else {
    error make {
      msg: "This requires Terminal 'Full Disk Access' permission to work properly"
    }
  }
}

## update command, 仅仅是 brew ， 系统等 方面的更新

# check install brew
def asssert-brew [] {
  if (which brew | is-not-empty) {
    log debug "brew is exists"
    true
  } else {
    log error "Please install brew."
    false
  }
}

# brew update casks
def brew-casks-update [] {
  if assert-brew {
    let casks_tap = "buo/cask-upgrade"
    if ($casks_tap in (brew tap | lines)) {
      brew cu --all --cleanup --yes
    } else {
      log warning $"If you want to be able to pin a certain cask use the tap of '($casks_tap)'"
      brew update
      brew upgrade --cask
      brew cleanup
    }
  }
}

# brew update cli
def brew-cli-update [] {
  if assert-brew {
    log debug "use brew update command."
    brew update
    brew upgrade
  }
}

# software update
def software-list-format [s: string] {
  let info_lines = $s | lines --skip-empty | reduce -f { cur: "", out: [] } { |line, st|
    let l = ($line | str trim)
    if ($l | str starts-with '* Label:') {
      if $st.cur != "" {
        {
          cur: $l
          out: ($st.out | append $st.cur)
        }
      } else {
        {
          cur: $l
          out: $st.out
        }
      }
    } else if $st.cur != "" and $l != "" {
      {
        cur: $"($st.cur) ($l)"
        out: $st.out
      }
    } else {
      $st
    }
  } | update out {|st|
    if $st.cur != "" {
      $st.out | append $st.cur
    } else {
      $st.out
    }
  } | get out

  # format
  let reg_pares = '\* Label:\s*(?<label>.*)\s+Title:\s+(?<title>.*?),\s+Version:\s*(?<version>[0-9.]+),\s*Size:\s+(?<size>[0-9KiB]+),\s*Recommended:\s*(?<recommended>YES|NO),\s*Action:\s*(?<action>\w+),'
  $info_lines | each {|x| $x | parse --regex $reg_pares } | flatten
}

# mac custom command
def main []: nothing -> any { help main }
