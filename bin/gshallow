#!/usr/bin/env nu
use std log

# 判断目录是否为 Git 仓库，添加 try
def is-git-repo [dir_path: string = "" ]: nothing -> bool {
  try {
    let target = $dir_path | path expand
    log debug $"正在测试目录 ($target) 是否为 git 仓库"
    (git -C $target rev-parse --is-inside-work-tree | str trim) == "true"
  } catch {
    false
  }
}
# 获取 Git 根目录
def get-git-topdir [dir_path: string = ""]: nothing -> path {
  let target = $dir_path | path expand
  git -C $target rev-parse --show-toplevel | str trim | path expand
}
# 获取当前 git 仓库的 git-dir 文件，一般为 .git
def get-git-dir [dir_path: string = ""]: nothing -> path {
  let target = $dir_path | path expand
  $target | path join (git -C $target rev-parse --git-dir | str trim)
}
# 计算 Git 元数据占用大小
def du-git-repo [dir_path: string = ""]: nothing -> filesize {
  try {
    du (get-git-dir $dir_path) | get physical | math sum
  } catch {
    0b
  }
}


def is-git-url [url: string]: nothing -> string {
  let url_parse = $url | parse -r '^(?P<proto>https?://|ssh://|git@)(?P<host>[^:/]+)[:/]?(?P<path>.*)/(?P<name>[^/:]+?)(?:\.git)?/?$'
  if ($url_parse | is-empty) {
    null
  } else {$url_parse.0.name }
}


def main [
  url: string = "", # 克隆链接
  dir_path: string = "",
  --force(-f), # 是否删除 本地 tag
  --remote(-r), # 是否不获取远程最新 commit
] {
  mut target_dir = ""
  if ($url != "") {
    let _name = (is-git-url $url)
    if ($_name | is-not-empty) {
      $target_dir = (if ($dir_path | is-empty) { $_name } else { $dir_path }) | path expand
      mkdir ($target_dir | path dirname)
      if ($target_dir | path exists) {
        log error $"($target_dir) 已经存在无法克隆。"
        exit 1
      } else {
        log info $"开始克隆 ($url)..."
        git clone --depth 1 $url $target_dir
        log info "克隆完成"
        let _realpath = if ($target_dir | str starts-with $env.PWD) {
          $target_dir | path relative-to  $env.PWD
        } else {
          $target_dir
        }
        let save_size = du-git-repo $target_dir
        log info $"($_realpath) 仓库的 .git 大小：($save_size)"
        return $save_size
      }
    } else {
      $target_dir = $url | path expand
    }
  } else {
    $target_dir = $dir_path
  }
  if ( (is-git-repo  $target_dir) != true ) {
    log error $"当前路径 [($target_dir)] 不是一个 git 仓库."
    exit 1
  }
  let git_dir = get-git-topdir  $target_dir
  let initial_size = du-git-repo $git_dir
  log info $"($git_dir) .git 仓库大小: ($initial_size)"
  # 转换为浅层仓库，只保留一次提交
  cd $git_dir
  let main_branch = git rev-parse --abbrev-ref HEAD
  if $remote {
    git fetch --depth 1 origin $main_branch
    if $force {
      let tags = (git tag -l --sort=creatordate | lines)
      if ($tags | is-not-empty) {
        $tags | each {|x| git tag -d $x }
      }
      let local_branch = git branch | lines | each { |it| $it | str trim}
      if (($local_branch | length) >= 2) {
        $local_branch | where ($it | str starts-with "*")
                      | each { |it| git branch -D $it }
      }
    } else {
      log info "正在清理旧标签，保留最新一个..."
      # 1. 获取按时间排序的所有标签（最后一行是最新的）
      let tags = (git tag -l --sort=creatordate | lines)
      # 2. 如果标签数量大于 1，则删除除最后一个之外的所有标签
      if ($tags | length) > 1 {
          let tags_to_delete = ($tags | drop 1) # 移除列表最后一个（即保留最新的）
          $tags_to_delete | each {|x|
              log debug $"删除旧标签: ($x)"
              git tag -d $x
          }
      } else {
          log debug "只有一个标签或无标签，无需清理。"
      }
    }
  } else {
    git reset --hard HEAD
    git clean -ffd
    try {
      git replace --graft HEAD
    } catch {
      log info $"($env.PWD) is already compact"
    }
    git tag -l | lines | each {|x| git tag -d $x }
    let local_branch = git branch | lines | each { |it| $it | str trim} | where ($it | str starts-with "*") != true
    if ($local_branch | is-not-empty) {
      $local_branch | each { |it| git branch -D $it }
    }
    # git branch -r | awk -F'/' '{print $1"/"$2}' | xargs -n2 git branch -r -d
    let remote_branch = git branch -r | lines
                                      | each { |it| $it | str trim }
                                      | where (($it | str ends-with $main_branch ) != true)
    if ($remote_branch | is-not-empty) {
      $remote_branch | each { |it|
        let parts = ($it | str trim | split row "/")
        if ($parts | length) == 2 {
            let remote_ref = $"($parts.0)/($parts.1)"
            git branch -r -d $remote_ref
        }
      }
    }
  }

  # 彻底断开与旧历史的联系
  try {
    # git repack -a -d --depth=1 --window=1
    if force {
        git repack -a -d -f -F --window=250 --depth=250
    }
    git reflog expire --expire=now --all
    git gc --prune=now --aggressive --force
    # if ($remote == false) {
      # let shallow_file = get-git-dir $git_dir | path join "shallow"
      # git rev-parse HEAD | save -f $shallow_file
    # }
  } catch {
    let broken_commit = git fsck --full | lines | where ($it | str starts-with  "broken")  | each {|$it| $it | str trim | parse -r 'broken link from\s+commit\s+(?P<commit>.*)' } | get commit | each {|it| $it.0 }
    let _git_dir = get-git-dir
    for i in $broken_commit {
      let _file = $_git_dir | path join
    }
  }
  let final_size = du-git-repo $target_dir
  log info $"清理后 .git 目录大小: ($final_size)"
  # 计算节省大小
  let saved_size = $initial_size - $final_size
  log info $"共节省了约: (ansi defd)(ansi defu)($saved_size)(ansi reset)"
  return $saved_size
}
